<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zteshadow.github.io/</id><title>zteshadow</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-12-30T10:35:54+08:00</updated> <author> <name>zteshadow</name> <uri>https://zteshadow.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://zteshadow.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://zteshadow.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 zteshadow </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>MVC, MVP, MVVM, VIPER and MVVMC(SwiftUI) All In One</title><link href="https://zteshadow.github.io/posts/mvc-mvp-mv-all-in-one/" rel="alternate" type="text/html" title="MVC, MVP, MVVM, VIPER and MVVMC(SwiftUI) All In One" /><published>2022-11-05T11:09:00+08:00</published> <updated>2022-12-30T10:32:29+08:00</updated> <id>https://zteshadow.github.io/posts/mvc-mvp-mv-all-in-one/</id> <content src="https://zteshadow.github.io/posts/mvc-mvp-mv-all-in-one/" /> <author> <name>zteshadow</name> </author> <category term="BestPractice" /> <summary> Architecture iOS开发最初遵循原始的MVC架构, 但是随着业务的演进代码越来越复杂, 很容易变成Massive View Controller, 最终导致代码难以维护, 难以测试, 难以复用. 为了解决这个问题逐步演化出: MVP MVVM VIPER MVVM-C 等架构. 今天我们就用各个架构实现一个ToDoList来看看他们是如何解决问题的以及各自的优缺点. 要实现的功能是一个to do list页面, 功能如下: 点击删除条目 点击+添加条目 输入字符超过3个(包含)才可添加 示例如下: 1. MVC 源代码 标准的MVC结构如下, 我们把model和business logic都放在controller中. 接收用户interaction 更新model 更新view // 点击删除it... </summary> </entry> <entry><title>Best Practice iOS Part3 - Dependency injection</title><link href="https://zteshadow.github.io/posts/best-practiceios-3-dependency-injection/" rel="alternate" type="text/html" title="Best Practice iOS Part3 - Dependency injection" /><published>2022-06-17T09:30:00+08:00</published> <updated>2022-06-20T07:03:49+08:00</updated> <id>https://zteshadow.github.io/posts/best-practiceios-3-dependency-injection/</id> <content src="https://zteshadow.github.io/posts/best-practiceios-3-dependency-injection/" /> <author> <name>zteshadow</name> </author> <category term="BestPractice" /> <summary> Why we need dependency injection 1. Dependency Dependency is the connection between modules, take BookList module for example, it needs lots of services, such as: Network for data retrieving Track for event tracking UserDefault for simple configuration Notification Center for notification let’s take Track as an example, maybe we are now using AppCenter as our tracking platform (it ... </summary> </entry> <entry><title>Best Practice iOS Part2 - Modules</title><link href="https://zteshadow.github.io/posts/best-practiceios-2-module/" rel="alternate" type="text/html" title="Best Practice iOS Part2 - Modules" /><published>2022-06-17T07:32:00+08:00</published> <updated>2022-06-17T10:35:32+08:00</updated> <id>https://zteshadow.github.io/posts/best-practiceios-2-module/</id> <content src="https://zteshadow.github.io/posts/best-practiceios-2-module/" /> <author> <name>zteshadow</name> </author> <category term="BestPractice" /> <summary> How to divide modules Modules can be divided by different perspective, and usually there are two different perspectives: function and business, from the functional perspective, Network, Dependency injection are different modules, and from the business perspective(shown as below), Club, Book, Food, and Profile are different modules. There are also some other factors usually being taken into co... </summary> </entry> <entry><title>Best Practice iOS Part1 - Start</title><link href="https://zteshadow.github.io/posts/best-practiceios-1-start/" rel="alternate" type="text/html" title="Best Practice iOS Part1 - Start" /><published>2022-06-02T14:41:00+08:00</published> <updated>2022-06-17T10:35:32+08:00</updated> <id>https://zteshadow.github.io/posts/best-practiceios-1-start/</id> <content src="https://zteshadow.github.io/posts/best-practiceios-1-start/" /> <author> <name>zteshadow</name> </author> <category term="BestPractice" /> <summary> Best practice - artistry I’ve been a software engineer for more than 16 years, have been using C, C++, Objective-C, Swift lauguage and have built lots of products such as USB driver on digital wireless phone, video chat application on feature phone, input method on both feature phone and iPhone, and recently a iOS application for e-commercial. I’ve been stumbled and occasionally lost in the s... </summary> </entry> <entry><title>Main Entry For iOS Application</title><link href="https://zteshadow.github.io/posts/mainentryforapplication/" rel="alternate" type="text/html" title="Main Entry For iOS Application" /><published>2022-04-12T07:32:00+08:00</published> <updated>2022-05-25T08:21:44+08:00</updated> <id>https://zteshadow.github.io/posts/mainentryforapplication/</id> <content src="https://zteshadow.github.io/posts/mainentryforapplication/" /> <author> <name>zteshadow</name> </author> <category term="Foundation" /> <summary> 我们知道所有程序的主入口是main函数, 这个概念在C语言里面的实现简单而直接. int main(int argc, char **argv) { printf("hello world\n"); return 0; } 对于一个与用户交互的应用程序, 初始化之后通常会构造交互界面(比如CLI会接受用户输入), 然后进入事件循环处理各种用户事件, 系统事件, 伪代码如下. int main(int argc, char **argv) { printf("hello world\n"); while (event) { // do process } return 0 } iOS应用程序 - 无论是基于Objective-C, 还是基于SwiftUI, 尽管实现方式不同, 模式都是相通的, 主入口提供功能: 初始... </summary> </entry> </feed>
