[ { "title": "MVC, MVP, MVVM, VIPER and MVVMC(SwiftUI) All In One", "url": "/posts/mvc-mvp-mv-all-in-one/", "categories": "BestPractice", "tags": "iOS, SwiftUI, Swift, MVVM, MVC, MVP, VIPER, MVVMC", "date": "2022-11-05 11:09:00 +0800", "snippet": "ArchitectureiOS开发最初遵循原始的MVC架构, 但是随着业务的演进代码越来越复杂, 很容易变成Massive View Controller, 最终导致代码难以维护, 难以测试, 难以复用. 为了解决这个问题逐步演化出: MVP MVVM VIPER MVVM-C等架构. 今天我们就用各个架构实现一个ToDoList来看看他们是如何解决问题的以及各自的优缺点.要实现的功能是一个to do list页面, 功能如下: 点击删除条目 点击+添加条目 输入字符超过3个(包含)才可添加示例如下:1. MVC源代码标准的MVC结构如下, 我们把model和business logic都放在controller中. 接收用户interaction 更新model 更新view// 点击删除itemoverride func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { guard indexPath.section == Section.todos.rawValue else { return } todos.remove(at: indexPath.row) //更新model title = &quot;TODO - (\\(todos.count))&quot; //更新model tableView.reloadData() //刷新View } 问题 无法测试business logic是否正确, 包括: 1. 添加时button的enabled状态是否正确2. 添加时新增的条目是否正确3. 是否删除正确的条目... View与business logic耦合在一起, 无法复用 1. 如果要换个界面比如卡片式, 整个代码都要修改, 无法复用现有的business logic 优点 代码量少, 开发速度快 不需要太多经验就能开发维护 MVP源代码MVP架构中, 将View+Controller组成一个PassiveView, PassiveView负责转发用户交互事件, 业务逻辑都在Presenter中实现, 由Presenter负责更新视图.protocol ToDoListView: AnyObject { func update(list: [String], title: String) func enableAdd(_ enable: Bool)}protocol ToDoListPresenter { func load() func remove(at index: Int) func edit(_ text: String) func add()}class ToDoListPresenterImpl: ToDoListPresenter { unowned var view: ToDoListView var todos: [String] = [] { didSet { view.update(list: todos, title: &quot;TODO - (\\(self.todos.count))&quot;) } } var text = &quot;&quot; { didSet { view.enableAdd(text.count &amp;gt;= 3) } } init(_ view: ToDoListView) { self.view = view }} Controller和Presenter的绑定:```swift…let controller: TableViewController = UIStoryboard(name: “Table”, bundle: nil) .instantiateViewController(withIdentifier: “tableViewController”) as! TableViewControllerlet presenter = ToDoListPresenterImpl(controller)controller.presenter = presentercontroller.navigationItem.hidesBackButton = trueself.navigationController?.pushViewController(controller, animated: false)…&amp;gt;&amp;lt;span style=&quot;color:red&quot;&amp;gt;注意`view`持有`presenter`, 而`presenter`连接`unowned view`&amp;lt;/span&amp;gt;业务逻辑在`presenter`中, 很容易通过mock view进行测试(代码覆盖率达到`97.8`).![](mvp-test.png)&amp;gt;&amp;lt;span style=&quot;color:red&quot;&amp;gt;问题&amp;lt;/span&amp;gt;- 需要手动将数据的变化绑定到view&amp;gt; 优点- 业务逻辑与view隔离, 容易测试- 业务逻辑与view隔离, 容易复用, 如果只修改界面, 换一个`ToDoListView`实现即可.## MVVM[源代码](https://github.com/zteshadow/best-practice/tree/main/native-ios/MVVM)![](mvvm.png)从架构图中也可以看到, `MVVM`架构与`MVP`架构基本相同, 但有以下几点区别- 对视图的更新, 在`MVP`中是手动实现的, 而`MVVM`中是自动完成的(用callback, combine, RxSwift技术等)- `view model`的设计原则是: 持有`view`中对应的状态, 修改状态 -&amp;gt; 自动更新view这点稍微比较隐晦, 比如在Presenter中, 更新todos会同步更新title, 因此Presenter中可以不持有title, 但是设计view model的时候, 一定是将view中需要的状态都保存在view model中.```swiftclass ToDoListViewModel { @Published var todos: [String] = [] { didSet { title = &quot;TODO - (\\(self.todos.count))&quot; } } @Published var title: String = &quot;&quot; @Published var enableAdd: Bool = false var text = &quot;&quot; { didSet { if text.count &amp;gt;= 3 { enableAdd = true } else { enableAdd = false } } }} business和view的耦合不同, 如果使用combine来实现MVVM中的绑定, 那么这个view model是和view紧密结合在一起的, 不像MVP中view与Presenter解耦的那么彻底, 更适合复用. 测试方式也不同, 同上, 如果使用combine来实现MVVM中的绑定, 那么一些基本的数据操作逻辑是不用测试的. VIPER源代码 与MVP的区别 将Presenter进一步的细化, 分拆出来Interactor和Router, 分别负责外部数据交互以及路由MVVMC Typical coordinator(统筹者,协调人)```swiftpublic protocol MyTicketsCoordinator: Coordinator { /// Creates a new view to show for the home-page tab. func createMyTicketsView() -&amp;gt; AnyView /// or func pushMyTicketsScreen() -&amp;gt; ChildCoordinator}/// The MyTickets public APIs to be used by other modulespublic protocol MyTicketsAPI { /// Creates a new coordinator for the home page. func createMyTicketsCoordinator(router: RoutingAPI) -&amp;gt; MyTicketsCoordinator}```总结架构的最终目的 UI可复用可更新 业务逻辑可测试" }, { "title": "Best Practice iOS Part3 - Dependency injection", "url": "/posts/best-practiceios-3-dependency-injection/", "categories": "BestPractice", "tags": "iOS, Swift, DI", "date": "2022-06-17 09:30:00 +0800", "snippet": "Why we need dependency injection1. DependencyDependency is the connection between modules, take BookList module for example, it needs lots of services, such as: Network for data retrieving Track for event tracking UserDefault for simple configuration Notification Center for notificationlet’s take Track as an example, maybe we are now using AppCenter as our tracking platform (it can be newrelic or any other platforms), and have codes in our project like this:public struct AppCenterTracker { public func logEvent(_ name: String, info: [String: String] = [:]) { // }}// used in other module such as BookListstruct BookListViewModel { private let tracker = AppCenterTracker() func loadBookList() async throws { tracker.logEvent(&quot;Load book list&quot;) }}The weakness of concreting tracker with specific implementation is obviously and it will be painfull if we change our tracking platform from AppCenter to Newrelic. so usually we use protocol oriented programming in Swift, here is the example.public protocol TrackingAPI { func logEvent(_ name: String, info: [String: String])}public struct AppCenterTracker: TrackingAPI { public func logEvent(_ name: String, info: [String: String] = [:]) { // }}struct BookListViewModel { private let tracker: TrackingAPI init(_ tracker: TrackingAPI) { self.tracker = tracker } func loadBookList() async throws { tracker.logEvent(&quot;Load book list&quot;, info: [:]) }}There are two types of dependency injection: initializer based factory basedIf there are only couple of dependencies needed, just like the tracker above, we can use the initializer based injection, and use factory based injection in more dependencies case.2. Benefits of dependency injectionLet’s recap the benefits of dependency injection here: 1. De-couplingUsing protocol instead of concrete implementation to de-couple the service user from service provider, will result in a flexibility of potential change 2. TestableMocked service provider can be easly used in unit testHow to create a dependency injection factoryLet’s create a simple dependency injection factory step by step.1. Interfacefirst we need to figure out the interface, and it is obviously simple.public protocol ServiceAPI { func registerService&amp;lt;T&amp;gt;(_ type: T.Type, _ builder: @escaping () -&amp;gt; T) func getService&amp;lt;T&amp;gt;(_ type: T.Type) -&amp;gt; T}2. Factory or singletonThere can be two types of service provider we can use, Factory or Singleton. The servcie we get from a Singleton provoder is always the same instance while we get a new instance of service everytime from a Factory provider.It’s usually a Singleton provider we needed, and we can easily extend our service by adding a new parameter in registerService like this.enum ServiceType { case factory, singleton}func registerService&amp;lt;T&amp;gt;(_ type: T.Type, _ service: ServiceType = .singleton, _ builder: @escaping () -&amp;gt; T)Now we just create a singleton service.3. Public and privateSometimes we need to share some open services among modules and hide the services only used within a module internally, just like this.Other modules such Module2 and Module3 can only get access the public services rather than private services provided by Module1.While within Module1, as a up-forward looking up, both private services and public services can be accessed.4. Practice Create Swift Package and design interface How to save key and closure Tree " }, { "title": "Best Practice iOS Part2 - Modules", "url": "/posts/best-practiceios-2-module/", "categories": "BestPractice", "tags": "iOS, SwiftUI, Swift, MVVM", "date": "2022-06-17 07:32:00 +0800", "snippet": "How to divide modulesModules can be divided by different perspective, and usually there are two different perspectives: function and business, from the functional perspective, Network, Dependency injection are different modules, and from the business perspective(shown as below), Club, Book, Food, and Profile are different modules.There are also some other factors usually being taken into consideration in modules dividing, such as Complexibility, Extension, Cooperation, take Book in the MVP as an example, creating a module named BookModule is a very common practice, but if both List and Detail page are very complicated with lots of fine UI elements, network API, taken by different team or, one of them will be in a Webview some day in future, then two modules of BookList and BookDetail are better choice.Usually below factors are worth consideration: UI complexity Extensionbility (may be taken place by a web page?) Cooperation (in different team or different team members) FunctionAnd of course, divied into finner moduels is always not bad ideaHere are the modules we need in our MVP: Network Dependency injection ClubList ClubDetails BookList BookDetails FoodList FoodDetails ProfileThe first two modules are functional modles while the other modules are business related.How to organize modulesThere are two ways we can organize our moduls: Xcode project Swift packageAnd some poins we need to take into consideration: Configuration Unit test SwiftUI preview LocalizationWe will use swift pacakge at first for all modules, and it will certainly be good for funtional modules such as Network and Dependency injection, but not sure for other business modules. We can discuss this later." }, { "title": "Best Practice iOS Part1 - Start", "url": "/posts/best-practiceios-1-start/", "categories": "BestPractice", "tags": "iOS, SwiftUI, Swift, MVVM", "date": "2022-06-02 14:41:00 +0800", "snippet": "Best practice - artistryI’ve been a software engineer for more than 16 years, have been using C, C++, Objective-C, Swift lauguage and have built lots of products such as USB driver on digital wireless phone, video chat application on feature phone, input method on both feature phone and iPhone, and recently a iOS application for e-commercial.I’ve been stumbled and occasionally lost in the shit of code mountain, until I was so lucky to meet some amazing guys in a beautiful team recently. I finally re-fall in love with coding and engineering and finally I realize that we need to persuit art out of normal life and work, that’s how we can enjoy our life.So I want to conclude some best practice in our daily work though some of it seems common sense, they are really fun our work more. hope you will enjoy it.1. Targetwe are going to build a MVP(minimum viable product) with tabs and navigation(shown in below image), and investigate the best practice to do this.Tech used: SwiftUI Combine await/asyncSubjects involved: MVVMC design pattern How to divide module Do we need a coordinator Dependency injection Navigator in SwiftUI Dark mode Unit test Localization Tracking Remote configuration2. Get startedLet’s initialize our HappyTime application follow this post. Simple, you can find project files here Code.3. MVVMWe can see here, the root view of tab view follow the MVVM pattern.Tag" }, { "title": "Main Entry For iOS Application", "url": "/posts/mainentryforapplication/", "categories": "Foundation", "tags": "", "date": "2022-04-12 07:32:00 +0800", "snippet": "我们知道所有程序的主入口是main函数, 这个概念在C语言里面的实现简单而直接.int main(int argc, char **argv) { printf(&quot;hello world\\n&quot;); return 0;}对于一个与用户交互的应用程序, 初始化之后通常会构造交互界面(比如CLI会接受用户输入), 然后进入事件循环处理各种用户事件, 系统事件, 伪代码如下.int main(int argc, char **argv) { printf(&quot;hello world\\n&quot;); while (event) { // do process } return 0}iOS应用程序 - 无论是基于Objective-C, 还是基于SwiftUI, 尽管实现方式不同, 模式都是相通的, 主入口提供功能: 初始化, 构造主界面, 进入事件循环.1. Objective-C 基于Objective-C的应用程序基于Objective-C的应用程序保持了C语言简单直接的风格, 应用程序创建后Xcode会自动生成main.m文件和main函数作为程序入口.#import &amp;lt;UIKit/UIKit.h&amp;gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) { NSString * appDelegateClassName; @autoreleasepool { // Setup code that might create autoreleased objects goes here. appDelegateClassName = NSStringFromClass([AppDelegate class]); } return UIApplicationMain(argc, argv, nil, appDelegateClassName);}程序会在UIApplicationMain中进行初始化, 构造UI, 进入Runloop处理用户交互与系统事件, 直到调用exit()退出程序或者异常终止.1.1 初始化与main.m文件同时生成的还有AppDelegate.m, 通常在didFinishLaunchingWithOptions中进行初始化操作.@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. return YES;}@end1.2 主界面启动程序完成初始化操作之后, 就要构造应用程序的交互界面了, 在Objective-C中是靠配置文件利用反射来完成的. Target -&amp;gt; General -&amp;gt; Main Interface指定Main storyboard Main storyboard中指定Custom Class为ViewController ViewController构造主界面上述配置存储在Info.plist文件中, 程序启动后读取配置, 利用Objective-C的反射机制初始化ViewController实例, 完成主界面构造.2. SwiftUI基于SwiftUI的应用程序结构更简单, 但是初始化部分稍微有些隐晦, 不易发现. 基于SwiftUI的应用程序2.1 入口与主界面import SwiftUI@mainstruct SwiftUIMainEntryApp: App { var body: some Scene { WindowGroup { ContentView() } }}与Objective-C应用程序不同, 基于SwiftUI的应用程序直接呈现的是主界面的构造代码, 程序入口和初始化被简化隐藏了. 主入口被简化成了一个@main标签, 该标签要求实例提供一个全局静态main函数作为入口, 全局只能有一个标识为@main的实例.public static func main()2.2 自定义初始化那么初始化操作该如何进行呢?答案是@UIApplicationDelegateAdaptor.@mainstruct SwiftUIMainEntryApp: App { // swiftlint:disable:next weak_delegate @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate var body: some Scene { WindowGroup { appDelegate.createContentView() } }}class AppDelegate: NSObject, UIApplicationDelegate, UISceneDelegate { override init() { super.init() } func createContentView() -&amp;gt; some View { ContentView() } func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -&amp;gt; Bool { return true }}我们需要自定义一个实现UIApplicationDelegate协议的类进行初始化操作.3. Simple MVVM application下面是一个简单的基于TabView的应用程序展示如何进行初始化以及创建主界面, 样式如下.3.1 View and View Model由于没有涉及到与外部的数据交互, 因此这里只有view和view model, 并没有MVVM中的第一个M: model. view modelclass RootViewModel: ObservableObject { @Published var tabList: [RootViewModelItem] var selected: TabType = .home init() { tabList = [ .init(id: .home, title: &quot;Home&quot;, image: Image(systemName: &quot;house&quot;), backgroundColor: .red), .init(id: .setting, title: &quot;Setting&quot;, image: Image(systemName: &quot;gear&quot;), backgroundColor: .blue) ] }}enum TabType: Int, Hashable { case home, setting}struct RootViewModelItem: Identifiable { var id: TabType var title: LocalizedStringKey var image: Image var backgroundColor: Color} viewstruct RootView: View { @ObservedObject var viewModel: RootViewModel var body: some View { TabView(selection: $viewModel.selected) { ForEach (viewModel.tabList) { item in tabView(item) .tabItem { item.image Text(item.title) } } } } func tabView(_ item: RootViewModelItem) -&amp;gt; some View { NavigationView { ZStack { item.backgroundColor Text(item.title) }.navigationTitle(item.title) } }}3.2 初始化与主界面构造 入口与初始化@mainstruct SimpleApp: App { @UIApplicationDelegateAdaptor var appDelegate: AppDelegate var body: some Scene { WindowGroup { appDelegate.createRootView() } }} 主界面构造class AppDelegate: NSObject, UIApplicationDelegate { private let rootViewModel: RootViewModel override init() { rootViewModel = RootViewModel() } func createRootView() -&amp;gt; some View { return RootView(viewModel: rootViewModel) }}完整代码" }, { "title": "RadioGroup Picker for iOS", "url": "/posts/radiogroup-picker-for-ios/", "categories": "Artistry, SwiftUI", "tags": "", "date": "2022-01-08 21:48:00 +0800", "snippet": "1. 当前的SwiftUI PickerSwiftUI提供了一个Picker控件用来进行选择操作, 目前支持segmented, inline, wheel, menu四种种样式, 接口简单, 使用方便, 效果也不错.接口:struct Picker&amp;lt;Label, SelectionValue, Content&amp;gt; : View where Label : View, SelectionValue : Hashable, Content : View使用:Picker(&quot;&quot;, selection: $selectedFlavorFromSegment) { Text(&quot;Chocolate&quot;).tag(Flavor.chocolate) Text(&quot;Vanilla&quot;).tag(Flavor.vanilla) Text(&quot;Strawberry&quot;).tag(Flavor.strawberry)}.pickerStyle(.segmented)效果:2. 简单的RadioGroup PickerSwiftUI只为macOS提供了radioGroup样式, iOS并没有对应的支持. 如果要实现简单的统一样式的radio group picker也不难, 参考Picker的设计, 实现一个支持数组输入的RadioGroupPicker.使用:RadioGroupPicker(&quot;&quot;, selection: $selectedFlavor) { [ Text(&quot;Chocolate&quot;).radioTag(Flavor.chocolate), Text(&quot;Vanilla&quot;).radioTag(Flavor.vanilla), Text(&quot;Strawberry&quot;).radioTag(Flavor.strawberry) ]} 注意1: 传入的参数是数组 注意2: 自定义radioTag函数传入tag, 因为SwiftUI中的View.tag无法获取参考源代码中的RadioGroupPicker+String.swift2.1 问题: radio tag的存取如果使用系统内置的View.tag, 我们无法得到tag的值, 因此只能自己添加函数radioTag获取tag值. /// cause some View is generic with constrain, cant&#39;t saved in list, so `AnyView` needed func radioTag&amp;lt;T: Hashable&amp;gt;(_ tag: T) -&amp;gt; AnyView where T: Hashable最初的思路是参考View.tag, 返回View, 这样便于在SwiftUI中继续构建View, 但是这样设计有个问题, 由于传入的是[AnyView], 因此在RadioGroupPickerSimple内部需要从AnyView中获取radioTag的值, 由于radioTag也是一个Generic with constrain, 因此无法扩展AnyView来存储(如果有方法, 请及时指正, 谢谢)只能得到导致这样的, 给View添加环境变量radio tag, 存储[View], 在选择的时候取出环境变量即可, 这样做甚至可以利用现有的ViewBuilder优化传入的数组, 但是环境变量容易设置, 取出却只能通过@Envrionment这个property wrapper进行, 因此无法用envrionment把radio tag存储在View中.那么能否自定义存储机制, 把radio tag存储到View中呢, 由于View是一个带有associatedtype的协议, 所以无法把radio tag存储在View中.那么能否存储在AnyView中呢, 再试试, 无法在View/AnyView内部存储radio tag那么就只能退化到外部存储结构了, 在View外部存储radio tag所以自定义存储结构, 把view和radio tag的关系存储起来, 这样以来会导致一个小缺陷: Text(“hi”).radioTag(“sdf”)返回的不是一个view, 而是自定义的结构定义外部结构:struct RadioGroupItem where SelectionValue: Hashable { var content: AnyView var tag: SelectionValue}在RadioGroupPickerSimple内部展示List of RadioGroupItem, 并响应点击选择.3. 支持自定义的RadioGroup Picker4. 完全自定义的RadioGroup Picker" }, { "title": "Hello World", "url": "/posts/hello-world/", "categories": "Life", "tags": "", "date": "2022-01-08 07:03:00 +0800", "snippet": "Hello world! This is my first post, and also the start of the rest of my life:)Hi, 这是我的第一篇blog, 好好生活, 学习和思考!" } ]
